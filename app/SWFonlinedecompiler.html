<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SWF Asset Extractor (Client‑Side, v2)</title>
  <style>
    :root { --bg:#0b0f14; --panel:#121822; --ink:#e6f1ff; --muted:#9bb0c2; --accent:#67bfff; --ok:#7ef7c9; --bad:#ff8a8a; --card:#0f1520; --border:#233044; }
    *{box-sizing:border-box} html,body{height:100%} body{margin:0;font:14px/1.5 system-ui,-apple-system,Segoe UI,Roboto,Noto Sans,Apple SD Gothic Neo,Malgun Gothic,sans-serif;background:radial-gradient(1200px 800px at 70% -10%,#11203a 0%,#0b0f14 40%,#0b0f14 100%);color:var(--ink)}
    header{padding:24px 20px 8px} h1{margin:0;font-size:20px;letter-spacing:.2px} header p{margin:6px 0 0;color:var(--muted)}
    main{padding:16px 20px 40px;display:grid;gap:16px;grid-template-columns:1fr;max-width:1100px;margin:0 auto}
    .drop{border:2px dashed var(--border);border-radius:16px;padding:24px;background:linear-gradient(180deg,rgba(255,255,255,.02),rgba(255,255,255,0));display:grid;place-items:center;gap:10px;text-align:center;transition:border-color .2s ease,background .2s ease}
    .drop.dragover{border-color:var(--accent);background:linear-gradient(180deg,rgba(103,191,255,.12),rgba(255,255,255,0))}
    .drop input{display:none} .drop .btn{display:inline-block;padding:10px 14px;background:var(--accent);color:#03121e;border-radius:10px;font-weight:600;cursor:pointer}
    .meta{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:12px}
    .meta .card{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px 14px}
    .list{display:grid;gap:12px}
    .asset{background:var(--card);border:1px solid var(--border);border-radius:14px;padding:12px;display:grid;grid-template-columns:64px 1fr auto;gap:12px;align-items:center}
    .thumb{width:64px;height:64px;border:1px solid var(--border);border-radius:10px;background:#0b121c;display:grid;place-items:center;overflow:hidden}
    .thumb img{max-width:100%;max-height:100%;display:block}
    .thumb .icon{font-size:20px;color:var(--muted)}
    .asset h3{margin:0;font-size:15px} .asset .sub{color:var(--muted);font-size:12px} .asset .actions{display:flex;gap:8px}
    .btn-ghost{padding:8px 10px;border:1px solid var(--border);background:#111827;color:var(--ink);border-radius:10px;text-decoration:none}
    .btn-ghost:hover{border-color:var(--accent);color:#fff}
    .audio{width:280px;max-width:45vw}
    .footer{color:var(--muted);font-size:12px;text-align:center;margin-top:10px}
    .warn{color:var(--bad)} .ok{color:var(--ok)}
    @media (max-width:640px){.asset{grid-template-columns:48px 1fr}.asset .actions{grid-column:1 / -1}.audio{width:100%}}
  </style>
</head>
<body>
  <header>
    <h1>SWF Asset Extractor — v2 (브라우저 전용)</h1>
    <p>FWS/CWS 지원, ZWS(LZMA) 미지원. 이미지: DefineBits / JPEG2 / JPEG3+알파 / Lossless2, 오디오: MP3(DefineSound). <span class="ok">JPEG 스트림 정리(sanitize) 적용</span>.</p>
  </header>
  <main>
    <section class="drop" id="drop">
      <div>
        <div style="font-size:48px; line-height:1">📦</div>
        <div style="margin:6px 0 10px">여기에 SWF 파일을 끌어다 놓거나…</div>
        <label class="btn" for="file">파일 선택</label>
        <input id="file" type="file" accept=".swf,application/x-shockwave-flash" />
      </div>
    </section>

    <section class="meta" id="meta" hidden>
      <div class="card"><div>시그니처</div><strong id="sig"></strong></div>
      <div class="card"><div>버전</div><strong id="ver"></strong></div>
      <div class="card"><div>파일 크기</div><strong id="len"></strong></div>
      <div class="card"><div>추출 결과</div><strong id="count"></strong></div>
    </section>

    <section class="list" id="list"></section>

    <div class="footer">브라우저에서만 처리. 최신 크롬/엣지 권장. 문제가 계속되면 파일이 ZWS(LZMA)이거나 특수 코덱(스트리밍 비디오)일 가능성.</div>
  </main>

<script>
// ---------- helpers ----------
const $ = sel => document.querySelector(sel);
const fmtBytes = n => { if (!Number.isFinite(n)) return '-'; const u=['B','KB','MB','GB']; let i=0; while(n>=1024&&i<u.length-1){n/=1024;i++;} return n.toFixed(n<10&&i?2:0)+' '+u[i]; };
const blobUrl = blob => URL.createObjectURL(blob);
const toBlob = (arr, type) => new Blob([arr], {type});

function sanitizeJPEG(u8){
  // Trim to start at first SOI (FFD8)
  let i = 0, found = -1;
  for (i=0;i<u8.length-1;i++){ if (u8[i]===0xFF && u8[i+1]===0xD8){ found=i; break; } }
  if (found>0) u8 = u8.subarray(found);
  // Collapse duplicated SOI (FFD8 FFD8 ...)
  while (u8.length>=4 && u8[0]===0xFF && u8[1]===0xD8 && u8[2]===0xFF && u8[3]===0xD8){
    u8 = u8.subarray(2);
  }
  // Ensure ends with EOI (FFD9); if there are trailing garbage bytes, cut at last EOI.
  let lastEOI = -1;
  for (let j=1;j<u8.length;j++){ if (u8[j-1]===0xFF && u8[j]===0xD9){ lastEOI = j; } }
  if (lastEOI>=0 && lastEOI < u8.length-1){ u8 = u8.subarray(0, lastEOI+1); }
  if (!(u8.length>=2 && u8[u8.length-2]===0xFF && u8[u8.length-1]===0xD9)){
    // append missing EOI
    const out = new Uint8Array(u8.length+2); out.set(u8,0); out.set([0xFF,0xD9], u8.length); u8 = out;
  }
  return u8;
}

// zlib inflate
async function inflateZlib(u8){
  if (window.DecompressionStream){
    const ds = new DecompressionStream('deflate');
    const out = (new Response(new Blob([u8])).body).pipeThrough(ds);
    const ab = await new Response(out).arrayBuffer();
    return new Uint8Array(ab);
  }
  throw new Error('이 브라우저는 DecompressionStream(deflate)을 지원하지 않는다. 최신 Chromium 계열을 사용해라.');
}

class ByteReader{
  constructor(arr){ this.arr=arr; this.dv=new DataView(arr.buffer, arr.byteOffset, arr.byteLength); this.pos=0; }
  tell(){ return this.pos; }
  seek(p){ this.pos=p; }
  skip(n){ this.pos+=n; }
  u8(){ return this.dv.getUint8(this.pos++); }
  u16(){ const v=this.dv.getUint16(this.pos,true); this.pos+=2; return v; }
  u32(){ const v=this.dv.getUint32(this.pos,true); this.pos+=4; return v; }
  bytes(n){ const s=this.arr.subarray(this.pos, this.pos+n); this.pos+=n; return s; }
}

async function parseSWF(arrayBuffer){
  let u8 = new Uint8Array(arrayBuffer);
  const srcSig = String.fromCharCode(u8[0],u8[1],u8[2]);
  const version = u8[3];

  if (srcSig === 'CWS'){
    const inflated = await inflateZlib(u8.subarray(8));
    const full = new Uint8Array(8 + inflated.length);
    full.set([70,87,83],0); // FWS
    full[3] = version;
    new DataView(full.buffer).setUint32(4, full.length, true);
    full.set(inflated, 8);
    u8 = full;
  } else if (srcSig === 'FWS') {
    // as-is
  } else if (srcSig === 'ZWS') {
    throw new Error('ZWS(LZMA) 압축은 아직 지원하지 않는다.');
  } else {
    throw new Error('SWF 시그니처가 잘못되었다: '+srcSig);
  }

  const r = new ByteReader(u8);
  r.seek(8);
  // RECT
  const rectStart = r.tell();
  const nbits = u8[rectStart] >> 3;
  const totalBits = 5 + nbits*4;
  const rectBytes = Math.ceil(totalBits/8);
  r.skip(rectBytes);
  // FrameRate(2), FrameCount(2)
  r.skip(4);

  const assets = [];
  const manifest = [];
  const asyncJobs = [];

  // Keep last seen JPEGTables for DefineBits
  let jpegTables = null;

  while (r.tell() + 2 <= u8.length){
    const codeAndLen = r.u16();
    const tagCode = codeAndLen >> 6;
    let len = codeAndLen & 0x3F;
    if (len === 0x3F) len = r.u32();
    if (len < 0 || r.tell()+len > u8.length) break;
    const data = r.bytes(len);

    switch (tagCode){
      case 8: { // JPEGTables
        // Entire JPEG table stream (usually a complete JFIF with DQT/DHT). We'll strip SOI/EOI later when merging.
        jpegTables = data;
        manifest.push({tag:8, type:'tables', bytes:data.length});
        break; }

      case 6: { // DefineBits (old JPEG uses external JPEGTables)
        const br = new ByteReader(data);
        const id = br.u16();
        let img = data.subarray(2);
        // Merge with JPEGTables if available
        if (jpegTables){
          const t = jpegTables;
          // strip SOI(FFD8)/EOI(FFD9) from tables
          let tStart = 0, tEnd = t.length;
          for (let i=0;i<t.length-1;i++){ if (t[i]===0xFF && t[i+1]===0xD8){ tStart = i+2; break; } }
          for (let j=t.length-1;j>0;j--){ if (t[j-1]===0xFF && t[j]===0xD9){ tEnd = j-1; break; } }
          const out = new Uint8Array(2 + (tEnd - tStart) + (img.length>2?img.length-2:img.length));
          let p = 0;
          out[p++]=0xFF; out[p++]=0xD8;
          out.set(t.subarray(tStart, tEnd), p); p += (tEnd - tStart);
          // append image without its own SOI if present
          if (img.length>=2 && img[0]===0xFF && img[1]===0xD8){ img = img.subarray(2); }
          out.set(img, p);
          img = out;
        }
        img = sanitizeJPEG(img);
        const blob = toBlob(img, 'image/jpeg');
        assets.push({type:'image', kind:'jpeg', id, name:`image_id${id}.jpg`, blob});
        manifest.push({tag:6, type:'image', id, bytes: img.length});
        break; }

      case 21: { // DefineBitsJPEG2
        const br = new ByteReader(data);
        const id = br.u16();
        let jpeg = data.subarray(2);
        jpeg = sanitizeJPEG(jpeg);
        const blob = toBlob(jpeg, 'image/jpeg');
        assets.push({type:'image', kind:'jpeg2', id, name:`image_jpeg2_id${id}.jpg`, blob});
        manifest.push({tag:21, type:'image', id, bytes: jpeg.length});
        break; }

      case 35: { // DefineBitsJPEG3 (JPEG + zlib alpha)
        const br = new ByteReader(data);
        const id = br.u16();
        const alphaOffset = br.u32();
        let jpeg = data.subarray(6, 6+alphaOffset);
        const alphaZ = data.subarray(6+alphaOffset);
        jpeg = sanitizeJPEG(jpeg);
        asyncJobs.push(processJPEG3(id, jpeg, alphaZ).then(list=>{ assets.push(...list); }));
        manifest.push({tag:35, type:'image', id, alpha:true});
        break; }

      case 36: { // DefineBitsLossless2
        const br = new ByteReader(data);
        const id = br.u16();
        const format = br.u8(); // 3=indexed, 5=32-bit RGBA
        const width = br.u16();
        const height = br.u16();
        let colorTableSize = null;
        if (format === 3) colorTableSize = br.u8();
        const z = data.subarray(br.tell());
        asyncJobs.push(processLossless2(id, format, width, height, colorTableSize, z).then(list=>{ assets.push(...list); }));
        manifest.push({tag:36, type:'image', id, format, width, height});
        break; }

      case 14: { // DefineSound
        const br = new ByteReader(data);
        const id = br.u16();
        const flags = br.u8();
        const fmt = (flags>>4)&0xF;
        const rate = (flags>>2)&0x3;
        const size = (flags>>1)&0x1;
        const stereo = (flags)&0x1;
        const samples = br.u32();
        if (fmt === 2){ // MP3
          br.u16(); // seekSamples
          const mp3 = data.subarray(2+1+4+2);
          const blob = toBlob(mp3, 'audio/mpeg');
          assets.push({type:'audio', kind:'mp3', id, name:`sound_id${id}.mp3`, blob});
        } else {
          const raw = data.subarray(br.tell());
          const blob = toBlob(raw, 'application/octet-stream');
          assets.push({type:'audio', kind:`format${fmt}`, id, name:`sound_id${id}_format${fmt}.bin`, blob});
        }
        manifest.push({tag:14, type:'audio', id, fmt, rate, size, stereo: !!stereo, samples});
        break; }

      case 87: { // DefineBinaryData
        const br = new ByteReader(data);
        const id = br.u16(); br.u32();
        const bin = data.subarray(6);
        const blob = toBlob(bin, 'application/octet-stream');
        assets.push({type:'binary', kind:'bin', id, name:`binary_id${id}.bin`, blob});
        manifest.push({tag:87, type:'binary', id, bytes: bin.length});
        break; }

      default:
        break;
    }
  }

  await Promise.all(asyncJobs);
  return {sig: String.fromCharCode(new Uint8Array(arrayBuffer)[0], new Uint8Array(arrayBuffer)[1], new Uint8Array(arrayBuffer)[2]), version, fileLength: new Uint8Array(arrayBuffer).length, assets, manifest};
}

async function processJPEG3(id, jpegBytes, alphaZ){
  const list = [];
  const jpegBlob = toBlob(jpegBytes, 'image/jpeg');
  try {
    const alpha = await inflateZlib(alphaZ);
    const bmp = await decodeImageBitmap(jpegBlob);
    const width = bmp.width, height = bmp.height;
    const canvas = document.createElement('canvas');
    canvas.width = width; canvas.height = height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(bmp, 0, 0);
    const img = ctx.getImageData(0,0,width,height);
    const d = img.data;
    if (alpha.length === width * height){
      for (let i=0, p=0; i<width*height; i++, p+=4){ d[p+3] = alpha[i]; }
      ctx.putImageData(img, 0, 0);
      const blob = await new Promise(res=>canvas.toBlob(res, 'image/png'));
      list.push({type:'image', kind:'jpeg3+alpha', id, name:`image_jpeg3_id${id}.png`, blob});
    } else {
      list.push({type:'image', kind:'jpeg3', id, name:`image_jpeg3_id${id}.jpg`, blob: jpegBlob});
      list.push({type:'binary', kind:'alpha', id, name:`image_jpeg3_id${id}_alpha.raw`, blob: toBlob(alpha,'application/octet-stream')});
    }
  } catch (e){
    list.push({type:'image', kind:'jpeg3', id, name:`image_jpeg3_id${id}.jpg`, blob: jpegBlob});
  }
  return list;
}

async function processLossless2(id, format, width, height, colorTableSize, z){
  const list = [];
  const data = await inflateZlib(z);
  if (format === 5){ // 32-bit RGBA (straight alpha), stored as ARGB
    const n = width*height;
    const canvas = document.createElement('canvas');
    canvas.width = width; canvas.height = height;
    const ctx = canvas.getContext('2d');
    const img = ctx.createImageData(width, height);
    const dst = img.data;
    for (let i=0, s=0, d=0; i<n; i++, s+=4, d+=4){
      const A = data[s+0], R = data[s+1], G = data[s+2], B = data[s+3];
      dst[d+0]=R; dst[d+1]=G; dst[d+2]=B; dst[d+3]=A;
    }
    ctx.putImageData(img,0,0);
    const blob = await new Promise(res=>canvas.toBlob(res, 'image/png'));
    list.push({type:'image', kind:'lossless2-32', id, name:`image_lossless2_id${id}_${width}x${height}.png`, blob});
  } else if (format === 3){ // indexed with (colorTableSize+1) entries, RGBA, rows padded to 4 bytes
    const palCount = (colorTableSize|0) + 1;
    let p = 0;
    const palette = new Uint8Array(palCount*4);
    for (let i=0;i<palCount;i++){ palette.set(data.subarray(p, p+4), i*4); p+=4; }
    const rowBytes = Math.ceil(width / 4)*4; // padded
    const canvas = document.createElement('canvas');
    canvas.width = width; canvas.height = height;
    const ctx = canvas.getContext('2d');
    const img = ctx.createImageData(width, height);
    const dst = img.data;
    for (let y=0; y<height; y++){
      const rowStart = p + y*rowBytes;
      for (let x=0; x<width; x++){
        const idx = data[rowStart + x];
        const si = idx*4; const di = (y*width + x)*4;
        dst[di+0]=palette[si+0]; dst[di+1]=palette[si+1]; dst[di+2]=palette[si+2]; dst[di+3]=palette[si+3];
      }
    }
    ctx.putImageData(img,0,0);
    const blob = await new Promise(res=>canvas.toBlob(res, 'image/png'));
    list.push({type:'image', kind:'lossless2-indexed', id, name:`image_lossless2_indexed_id${id}_${width}x${height}.png`, blob});
  } else {
    list.push({type:'binary', kind:`lossless2-format${format}`, id, name:`image_lossless2_id${id}_format${format}.bin`, blob: toBlob(data, 'application/octet-stream')});
  }
  return list;
}

async function decodeImageBitmap(blob){
  if (window.createImageBitmap){
    return await createImageBitmap(blob);
  }
  return new Promise((resolve, reject)=>{
    const img = new Image();
    img.onload = ()=> resolve(img);
    img.onerror = reject;
    img.src = URL.createObjectURL(blob);
  });
}

function renderResults(info){
  $('#meta').hidden = false;
  $('#sig').textContent = info.sig;
  $('#ver').textContent = info.version;
  $('#len').textContent = fmtBytes(info.fileLength);
  $('#count').textContent = `${info.assets.length}개 항목`;

  const wrap = $('#list');
  wrap.innerHTML = '';

  for (const a of info.assets){
    const card = document.createElement('div'); card.className = 'asset';
    const t = document.createElement('div'); t.className = 'thumb';
    if (a.type === 'image'){
      const img = document.createElement('img'); img.src = blobUrl(a.blob); img.alt = a.name; t.appendChild(img);
    } else if (a.type === 'audio' && a.kind === 'mp3'){
      const ic = document.createElement('div'); ic.className='icon'; ic.textContent='🎵'; t.appendChild(ic);
    } else {
      const ic = document.createElement('div'); ic.className='icon'; ic.textContent='📄'; t.appendChild(ic);
    }
    const meta = document.createElement('div');
    const h3 = document.createElement('h3'); h3.textContent = a.name;
    const sub = document.createElement('div'); sub.className='sub'; sub.textContent = `${a.type}${a.kind? ' · '+a.kind:''} · ${fmtBytes(a.blob.size)}`;
    meta.appendChild(h3); meta.appendChild(sub);
    const actions = document.createElement('div'); actions.className='actions';
    const aDownload = document.createElement('a'); aDownload.className = 'btn-ghost'; aDownload.href = blobUrl(a.blob); aDownload.download = a.name; aDownload.textContent = '다운로드';
    actions.appendChild(aDownload);
    if (a.type === 'audio' && a.kind === 'mp3'){ const audio = document.createElement('audio'); audio.className='audio'; audio.controls = true; audio.src = aDownload.href; actions.appendChild(audio); }
    card.appendChild(t); card.appendChild(meta); card.appendChild(actions);
    wrap.appendChild(card);
  }
}

async function handleFile(file){
  try {
    $('#list').innerHTML = ''; $('#meta').hidden = true;
    const ab = await file.arrayBuffer();
    const info = await parseSWF(ab);
    renderResults(info);
  } catch (err){
    const wrap = $('#list'); wrap.innerHTML = '';
    const div = document.createElement('div'); div.className = 'asset';
    div.innerHTML = `<div class="thumb"><div class="icon">⚠️</div></div><div><h3>추출 실패</h3><div class="sub">${(err&&err.message)||err}</div></div>`;
    wrap.appendChild(div);
  }
}

// ---------- UI ----------
const drop = $('#drop'); const input = $('#file');
input.addEventListener('change', e=>{ const f = e.target.files && e.target.files[0]; if (f) handleFile(f); });
['dragenter','dragover'].forEach(ev=> drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.add('dragover'); }));
;['dragleave','drop'].forEach(ev=> drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.remove('dragover'); }));
drop.addEventListener('drop', e=>{ const f = e.dataTransfer.files && e.dataTransfer.files[0]; if (f) handleFile(f); });
</script>
</body>
</html>
