<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>마우스 상태 점검</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    h1 {
      margin-bottom: 10px;
    }
    #controls button {
      margin: 5px;
      padding: 10px 15px;
      font-size: 16px;
      cursor: pointer;
    }
    .section {
      display: none;
      margin-top: 20px;
    }
    .section.active {
      display: block;
    }
    /* Double-click area */
    #doubleClickArea {
      width: 300px;
      height: 300px;
      background: #3cb043; /* green */
      display: flex;
      align-items: center;
      justify-content: center;
      color: #fff;
      font-size: 20px;
      user-select: none;
      cursor: pointer;
      border-radius: 6px;
    }
    #doubleMessage {
      font-weight: bold;
      margin-top: 8px;
    }
    /* Drag canvas */
    #dragCanvas {
      border: 1px solid #ccc;
      cursor: crosshair;
    }
    /* Wheel canvas */
    #wheelCanvas {
      border: 1px solid #ccc;
    }
  </style>
</head>
<body>
  <h1>마우스 상태 점검</h1>
  <div id="controls">
    <button data-target="double">더블클릭 테스트</button>
    <button data-target="drag">드래그 테스트</button>
    <button data-target="wheel">휠 테스트</button>
  </div>

  <!-- 더블클릭 테스트 -->
  <div id="double" class="section">
    <h2>더블클릭 테스트</h2>
    <div id="doubleClickArea">여기를 클릭</div>
    <p>
      전체 클릭 수: <span id="totalClicks">0</span> / 
      빠른 더블클릭 수: <span id="doubleCount">0</span>
    </p>
    <p id="doubleMessage" style="color:#c0392b; visibility:hidden;">⚠️ 비정상적으로 빠른 더블클릭 감지!</p>
  </div>

  <!-- 드래그 테스트 -->
  <div id="drag" class="section">
    <h2>드래그 테스트</h2>
    <canvas id="dragCanvas" width="800" height="400"></canvas><br />
    <button id="dragReset">리셋</button>
  </div>

  <!-- 휠 테스트 -->
  <div id="wheel" class="section">
    <h2>휠 테스트 (최근 1분)</h2>
    <canvas id="wheelCanvas" width="600" height="200"></canvas>
    <p style="font-size:14px; color:#555;">※ 휠 테스트 캔버스 안에서 마우스 휠을 굴려야 기록돼</p>
  </div>

  <script>
    // UI section toggling
    document.querySelectorAll('#controls button').forEach(btn => {
      btn.addEventListener('click', () => {
        const target = btn.dataset.target;
        document.querySelectorAll('.section').forEach(sec => {
          sec.classList.toggle('active', sec.id === target);
        });
      });
    });

    /* ---------------- 더블클릭 테스트 ---------------- */
    (function () {
      const area = document.getElementById('doubleClickArea');
      const msg = document.getElementById('doubleMessage');
      const fastSpan = document.getElementById('doubleCount');
      const totalSpan = document.getElementById('totalClicks');
      let lastClick = 0;
      let fastCount = 0;
      let totalCount = 0;

      area.addEventListener('click', () => {
        const now = Date.now();
        totalCount += 1;
        totalSpan.textContent = totalCount;
        if (now - lastClick <= 100) {
          // 비정상 빠른 더블클릭
          area.style.background = '#c0392b'; // 빨간색
          msg.style.visibility = 'visible';
          fastCount += 1;
          fastSpan.textContent = fastCount;
          setTimeout(() => {
            area.style.background = '#3cb043';
            msg.style.visibility = 'hidden';
          }, 2000);
        }
        lastClick = now;
      });
    })();

    /* ---------------- 드래그 테스트 ---------------- */
    (function () {
      const canvas = document.getElementById('dragCanvas');
      const ctx = canvas.getContext('2d');
      ctx.lineWidth = 2;
      ctx.lineCap = 'round';
      let drawing = false;

      function getPos(evt) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: evt.clientX - rect.left,
          y: evt.clientY - rect.top
        };
      }

      canvas.addEventListener('mousedown', evt => {
        drawing = true;
        const p = getPos(evt);
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
      });

      canvas.addEventListener('mousemove', evt => {
        if (!drawing) return;
        const p = getPos(evt);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      });

      window.addEventListener('mouseup', () => {
        drawing = false;
      });

      document.getElementById('dragReset').addEventListener('click', () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      });
    })();

    /* ---------------- 휠 테스트 ---------------- */
    (function () {
      const canvas = document.getElementById('wheelCanvas');
      const ctx = canvas.getContext('2d');
      const W = canvas.width;
      const H = canvas.height;
      const MID = H / 2;
      const events = [];

      canvas.addEventListener('wheel', evt => {
        evt.preventDefault();
        events.push({ time: Date.now(), up: evt.deltaY < 0 });
      }, { passive: false });

      function draw() {
        const now = Date.now();
        const start = now - 60000; // 1분 전
        // Remove old events
        while (events.length && events[0].time < start) events.shift();

        ctx.clearRect(0, 0, W, H);

        // midline
        ctx.strokeStyle = '#888';
        ctx.beginPath();
        ctx.moveTo(0, MID);
        ctx.lineTo(W, MID);
        ctx.stroke();

        const barWidth = 4;

        events.forEach(e => {
          const x = ((e.time - start) / 60000) * W;
          ctx.fillStyle = e.up ? '#c0392b' : '#2980b9';
          const barHeight = H / 2 * 0.9;
          if (e.up) {
            ctx.fillRect(x, MID - barHeight, barWidth, barHeight);
          } else {
            ctx.fillRect(x, MID, barWidth, barHeight);
          }
        });

        requestAnimationFrame(draw);
      }
      draw();
    })();
  </script>
</body>
</html>
