<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>마우스 상태 점검</title>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <style>
    :root{
      --bg: #0b0f14;
      --panel: rgba(255,255,255,0.06);
      --panel-2: rgba(255,255,255,0.10);
      --text: #e8edf2;
      --muted: #96a2b1;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; padding:20px 24px;
      font-family: ui-sans-serif, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Helvetica, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(1000px 700px at 10% 0%, #12202f 0%, transparent 60%),
        radial-gradient(1000px 700px at 90% 100%, #101a2b 0%, transparent 60%),
        linear-gradient(180deg, #0a0e13, #0b0f14 35%, #0b0f14 100%);
      overflow:hidden; /* 데스크톱 전용 */
      user-select:none;
    }
    h1{ margin:0 0 12px; font-size:24px; }
    #controls{ margin:8px 0 16px; }
    #controls button{
      margin:5px; padding:10px 15px; border:none; cursor:pointer;
      border-radius:10px; background:var(--panel); color:var(--text);
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.12);
    }
    #controls button:hover{ background:var(--panel-2) }
    .section{ display:none }
    .section.active{ display:block }

    /* 더블클릭 */
    #double h2, #drag h2, #wheel h2{ margin:8px 0 10px; font-size:16px; color:#aeb7c4 }
    #doubleClickArea{
      width:100%;
      height:80vh; min-height:420px;
      background:#3cb043; /* 초기색 유지 */
      display:flex; align-items:center; justify-content:center;
      color:#fff; font-size:22px; cursor:pointer;
      border-radius:12px;
      box-shadow:0 12px 28px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.14);
    }
    #doubleMessage{ font-weight:bold; margin-top:8px; color:#ffd5da; visibility:hidden }

    /* 드래그: 배경을 흰색으로 강제 */
    #dragCanvas{
      width:100%;
      height:80vh; min-height:420px;
      display:block;
      border:1px solid rgba(0,0,0,.15);
      background:#ffffff !important;
      border-radius:12px;
      box-shadow:0 12px 28px rgba(0,0,0,.20), inset 0 0 0 1px rgba(0,0,0,.06);
    }

    /* 휠: 넉넉하게 확대(초기 로직 유지) */
    #wheelCanvas{
      width:100%;
      height:46vh; min-height:260px;
      display:block;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.22);
      border-radius:12px;
      box-shadow:0 12px 28px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.08);
    }
  </style>
</head>
<body>
  <h1>마우스 상태 점검</h1>

  <div id="controls">
    <button data-target="double">더블클릭 테스트</button>
    <button data-target="drag">드래그 테스트</button>
    <button data-target="wheel">휠 테스트</button>
  </div>

  <!-- 더블클릭 -->
  <div id="double" class="section active">
    <h2>더블클릭 테스트</h2>
    <div id="doubleClickArea">여기를 클릭</div>
    <p>
      전체 클릭 수: <span id="totalClicks">0</span> /
      빠른 더블클릭 수: <span id="doubleCount">0</span>
    </p>
    <p id="doubleMessage">⚠️ 비정상적으로 빠른 더블클릭 감지!</p>
  </div>

  <!-- 드래그 -->
  <div id="drag" class="section">
    <h2>드래그 테스트</h2>
    <!-- 내부 버퍼 크기는 fit()에서 화면 크기에 맞춰 동적으로 설정 -->
    <canvas id="dragCanvas"></canvas><br/>
    <button id="dragReset">리셋</button>
  </div>

  <!-- 휠 -->
  <div id="wheel" class="section">
    <h2>휠 테스트 (최근 1분)</h2>
    <!-- 초기 로직 유지: 내부 버퍼 고정값 사용 -->
    <canvas id="wheelCanvas" width="1920" height="500"></canvas>
    <p style="font-size:14px; color:#aeb7c4;">※ 휠 테스트 캔버스 안에서 마우스 휠을 굴려줘</p>
  </div>

  <script>
    /* 섹션 전환: 초기 방식 */
    document.querySelectorAll('#controls button').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const target = btn.dataset.target;
        document.querySelectorAll('.section').forEach(sec=>{
          sec.classList.toggle('active', sec.id===target);
        });
        if(target==='drag'){ window.dispatchEvent(new Event('resize')); }
      });
    });

    /* 더블클릭: 초기 로직 유지 */
    (function(){
      const area = document.getElementById('doubleClickArea');
      const msg  = document.getElementById('doubleMessage');
      const fastSpan = document.getElementById('doubleCount');
      const totalSpan= document.getElementById('totalClicks');

      let lastClick=0, fast=0, total=0;

      area.addEventListener('click', ()=>{
        const now = Date.now();
        total++; totalSpan.textContent = total;
        if(now - lastClick <= 100){
          area.style.background = '#c0392b';
          msg.style.visibility = 'visible';
          fast++; fastSpan.textContent = fast;
          setTimeout(()=>{
            area.style.background = '#3cb043';
            msg.style.visibility = 'hidden';
          }, 2000);
        }
        lastClick = now;
      });
    })();

    /* 드래그: 초기 이벤트(mousedown/mousemove) 유지 + 좌표 정합/DPR 보정 + 내부 흰배경 */
    (function(){
      const canvas = document.getElementById('dragCanvas');
      const ctx = canvas.getContext('2d');

      let dpr=1, cssW=0, cssH=0, drawing=false;

      function fit(){
        dpr = Math.max(1, window.devicePixelRatio || 1);
        const r = canvas.getBoundingClientRect();
        cssW = r.width; cssH = r.height;

        // 내부 버퍼를 화면 크기*DPR로 설정
        canvas.width  = Math.max(1, Math.round(cssW * dpr));
        canvas.height = Math.max(1, Math.round(cssH * dpr));

        // 이후 그리기는 CSS 좌표로 (DPR 스케일 적용)
        ctx.setTransform(dpr,0,0,dpr,0,0);

        // 내부도 흰색으로 강제(가시성 보장)
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,0,cssW,cssH);

        // 선 스타일(초기값 유지)
        ctx.lineWidth = 2;         // CSS px 기준
        ctx.lineCap = 'round';
        ctx.lineJoin= 'round';
        ctx.strokeStyle = '#000000'; // 흰 배경에서 선명
      }

      function getPos(evt){
        const r = canvas.getBoundingClientRect();
        return { x: evt.clientX - r.left, y: evt.clientY - r.top };
      }

      canvas.addEventListener('mousedown', (evt)=>{
        drawing = true;
        const p = getPos(evt);
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
      });

      canvas.addEventListener('mousemove', (evt)=>{
        if(!drawing) return;
        const p = getPos(evt);
        ctx.lineTo(p.x, p.y);
        ctx.stroke();
      });

      window.addEventListener('mouseup', ()=>{ drawing=false; });

      const resetBtn = document.getElementById('dragReset');
      resetBtn.addEventListener('click', ()=>{
        ctx.setTransform(dpr,0,0,dpr,0,0);
        ctx.clearRect(0,0,cssW,cssH);
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0,0,cssW,cssH);
      });

      window.addEventListener('resize', fit);
      fit();
    })();

    /* 휠: 초기 로직 유지 */
    (function(){
      const canvas = document.getElementById('wheelCanvas');
      const ctx = canvas.getContext('2d');
      const W = canvas.width;
      const H = canvas.height;
      const MID = H/2;
      const events = [];

      canvas.addEventListener('wheel', (evt)=>{
        evt.preventDefault();
        events.push({ time: Date.now(), up: evt.deltaY < 0 });
      }, { passive:false });

      function draw(){
        const now = Date.now();
        const start = now - 60000; // 1분
        while(events.length && events[0].time < start) events.shift();

        ctx.clearRect(0,0,W,H);

        // 기준선
        ctx.strokeStyle = '#9aa6b2';
        ctx.beginPath(); ctx.moveTo(0,MID); ctx.lineTo(W,MID); ctx.stroke();

        const barW = 4;
        const barH = (H/2)*0.9;

        for(let i=0;i<events.length;i++){
          const e = events[i];
          const x = ((e.time - start)/60000)*W;
          ctx.fillStyle = e.up ? '#ff6e82' : '#46a5ff';
          if(e.up) ctx.fillRect(x, MID - barH, barW, barH);
          else     ctx.fillRect(x, MID,       barW, barH);
        }
        requestAnimationFrame(draw);
      }
      draw();
    })();
  </script>
</body>
</html>
