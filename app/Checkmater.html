<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>Seal‑Escape+ 9×9 (Mobile‑first, AI Teamplay)</title>
  <style>
    :root{
      --bg:#0f1115; --panel:#151821; --accent:#6aa5ff; --accent-2:#ff6ad5;
      --ok:#28c76f; --warn:#ffb84d; --danger:#ff5b5b; --line:#2a2f3a; --muted:#9aa3b2; --txt:#e6e9ef;
      --tile-a:#1b2030; --tile-b:#1e2536; --hl:#213245; --shadow:0 6px 20px rgba(0,0,0,.35);
    }
    *{box-sizing:border-box}
    body{margin:0;background:radial-gradient(1200px 600px at 70% -10%,#1b2130 0%,#0f1115 55%),var(--bg);color:var(--txt);
         font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,"Apple SD Gothic Neo","Noto Sans KR",sans-serif;
         display:flex;flex-direction:column;align-items:center;gap:.8rem;padding:clamp(.6rem,2.5vmin,1.2rem)}
    .wrap{width:min(96vw,960px);display:grid;gap:.8rem}
    header{display:flex;justify-content:space-between;align-items:center;gap:.6rem;padding:.8rem 1rem;border:1px solid var(--line);border-radius:14px;background:linear-gradient(180deg,rgba(255,255,255,.04),rgba(255,255,255,.02));box-shadow:var(--shadow)}
    h1{margin:0;font-size:clamp(1rem,3.6vmin,1.5rem);letter-spacing:.3px}
    .badges{display:flex;gap:.6rem;flex-wrap:wrap}
    .badge{display:inline-flex;align-items:center;gap:.4rem;border:1px solid var(--line);padding:.35rem .6rem;border-radius:999px;font-size:clamp(.72rem,2.2vmin,.95rem);background:#121620}
    .dot{width:.5rem;height:.5rem;border-radius:50%}

    #board{width:min(94vmin,560px);aspect-ratio:1/1;display:grid;grid-template-columns:repeat(9,1fr);grid-template-rows:repeat(9,1fr);
           border-radius:16px;overflow:hidden;border:1px solid var(--line);box-shadow:var(--shadow)}
    .cell{display:flex;align-items:center;justify-content:center;user-select:none;cursor:pointer;position:relative;
          font-size:clamp(.7rem,2.6vmin,1.05rem);transition:background .15s ease}
    .cell:nth-child(odd){background:var(--tile-a)}
    .cell:nth-child(even){background:var(--tile-b)}
    .cell:active{filter:brightness(1.05)}
    .cell.highlight{outline:2px solid var(--accent);z-index:1}

    .player{position:relative;background:linear-gradient(180deg,#2b8647,#1f6b38);color:#fff;z-index:2}
    .player::before{content:"";position:absolute;inset:16%;border-radius:50%;border:3px solid #34d399;box-shadow:0 0 10px rgba(52,211,153,.7),0 0 0 6px rgba(52,211,153,.16) inset}
    .player::after{content:"YOU";position:absolute;bottom:6%;right:6%;font-weight:900;font-size:clamp(.7rem,2.8vmin,1rem);padding:.05rem .35rem;border-radius:6px;background:rgba(52,211,153,.18);border:2px solid #34d399;color:#eafff6}

    .ai{position:relative;background:linear-gradient(180deg,#ad2e2e,#7f2020);color:#fff;z-index:2}
    .ai::before{content:"";position:absolute;inset:18%;transform:rotate(45deg);background:linear-gradient(180deg,#ff8d8d,#d44);box-shadow:0 0 10px rgba(255,107,107,.55)}
    .ai::after{content:"AI";position:absolute;top:6%;left:6%;font-weight:900;font-size:clamp(.7rem,2.8vmin,1rem);padding:.05rem .35rem;border-radius:6px;background:rgba(255,107,107,.16);border:2px solid #ff6b6b;color:#fff1f1}

    .tomb{background:#3a3f4a;color:#fff}
    .tomb::after{content:"†";position:absolute;inset:0;display:flex;align-items:center;justify-content:center;opacity:.92;font-weight:700}
    .sealed{background:#2d3447}
    .sealed::after{content:"✕";position:absolute;inset:0;display:flex;align-items:center;justify-content:center;color:var(--danger);font-weight:800}
    .rune{background:repeating-linear-gradient(45deg,#2e3b5a 0 12px,#2a3552 12px 24px)}
    .rune::after{content:"⛬";position:absolute;inset:0;display:flex;align-items:center;justify-content:center;opacity:.95}
    .key::after{content:"🔑";position:absolute}
    .gate::after{content:"🚪";position:absolute}
    .trap::after{content:"⚠";position:absolute}

    .info{display:grid;grid-template-columns:1fr auto;gap:.8rem;align-items:center}
    .stats{display:flex;gap:.6rem;flex-wrap:wrap}
    .pill{padding:.45rem .75rem;border-radius:999px;border:1px solid var(--line);background:#131925;font-size:clamp(.75rem,2.2vmin,.95rem)}
    .pill b{font-weight:700;color:var(--accent)}
    .panel{display:flex;gap:.5rem;flex-wrap:wrap;padding:.7rem;border:1px solid var(--line);background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.02));border-radius:14px}
    .legend{display:flex;gap:.5rem;flex-wrap:wrap;align-items:center;margin-top:.2rem}
    .lg{display:inline-flex;align-items:center;gap:.45rem;padding:.25rem .55rem;border-radius:999px;border:1px solid var(--line);background:#111825;font-size:clamp(.72rem,2.1vmin,.95rem)}
    .chip{width:1rem;height:1rem;border-radius:50%}
    .chip.p{border:3px solid #34d399;box-shadow:0 0 8px rgba(52,211,153,.65),0 0 0 4px rgba(52,211,153,.15) inset}
    .chip.a{background:linear-gradient(180deg,#ff8d8d,#d44);clip-path:polygon(50% 0,100% 50%,50% 100%,0 50%)}

    button{padding:.55rem .9rem;border-radius:10px;border:1px solid var(--line);background:#141b29;color:var(--txt);cursor:pointer;font-size:clamp(.85rem,2.4vmin,1rem)}
    button[disabled]{opacity:.5;cursor:not-allowed}
    /* mobile gesture hint to avoid 300ms delay / ghost clicks */
    button, #board .cell{ touch-action: manipulation; }
    .accent{border-color:transparent;background:linear-gradient(180deg,#6aa5ff,#4e8beb);color:#061222}

    #message{min-height:1.3rem;color:var(--muted)}

    @media (max-width:480px){
      header{padding:.7rem .8rem}
      .panel{gap:.4rem}
      button{padding:.5rem .75rem}
    }
      /* Ensure panels sit above board on mobile */
    header, .info .panel, #actions{ position:relative; z-index:5 }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Seal‑Escape+ 9×9</h1>
      <div class="badges">
        <span class="badge"><span class="dot" style="background:var(--accent)"></span> 모바일 최적화</span>
        <span class="badge"><span class="dot" style="background:var(--ok)"></span> 템포 유지, 플레이타임 ↑</span>
        <span class="badge"><span class="dot" style="background:var(--accent-2)"></span> AI 팀플레이</span>
      </div>
    </header>

    <div class="info">
      <div class="stats">
        <div class="pill">턴 <b id="turnNum">0</b></div>
        <div class="pill">봉인 해제까지 <b id="turnsLeft">5</b></div>
        <div class="pill">에너지 <b id="energy">1</b>/5</div>
        <div class="pill">키 <b id="keys">0</b>/3</div>
      </div>
      <div class="panel" id="controls">
        <button id="startBtn" class="accent">게임시작</button>
        <button id="restartBtn" style="display:none">다시시작</button>
      </div>
    </div>

    <div class="legend">
      <span class="lg"><span class="chip p"></span>플레이어</span>
      <span class="lg"><span class="chip a"></span>AI</span>
      <span class="lg">🔑 키</span>
      <span class="lg">🚪 게이트</span>
      <span class="lg">⚠ 함정</span>
      <span class="lg">✕ 봉인 / ⛬ 강봉인</span>
    </div>

    <div id="board"></div>

    <div id="message"></div>

    <div class="panel" id="actions" style="display:none">
      <button data-act="seal">봉인(기본)</button>
      <button data-act="trap">함정 설치(‑2E)</button>
      <button data-act="rune">강봉인(‑1E)</button>
      <button data-act="skip" data-postkeys="1" style="display:none">스킵</button>
      <button data-act="dispel" data-postkeys="1" style="display:none">해체(‑3E)</button>
    </div>
  </div>

<script>
(function(){
  'use strict';
  // ===== Config =====
  var SIZE=9, UNSEAL_INTERVAL=5, UNSEAL_COUNT=2, TOTAL_KEYS=3, MAX_ENERGY=5;
  var dirs=[[1,0],[-1,0],[0,1],[0,-1]];
  function inBounds(r,c){ return r>=0 && r<SIZE && c>=0 && c<SIZE; }
  function nonBorder(r,c){ return r>0 && r<SIZE-1 && c>0 && c<SIZE-1; }

  // ===== DOM =====
  var boardEl=document.getElementById('board');
  var msgEl=document.getElementById('message');
  var turnEl=document.getElementById('turnNum');
  var leftEl=document.getElementById('turnsLeft');
  var energyEl=document.getElementById('energy');
  var keysEl=document.getElementById('keys');
  var startBtn=document.getElementById('startBtn');
  var restartBtn=document.getElementById('restartBtn');
  var actionsEl=document.getElementById('actions');

  function logMsg(t){ if(msgEl){ msgEl.textContent=t; } }
  window.addEventListener('error', function(e){ logMsg('에러: '+(e && e.message ? e.message : '알 수 없음')); });

  // unify pointer/touch/click
  function bindPress(el, handler){ if(!el) return; var seen=false; el.addEventListener('pointerup', function(ev){ seen=true; try{ ev.preventDefault(); }catch(_){} handler({currentTarget:el, originalEvent:ev}); setTimeout(function(){ seen=false; },50); }, {passive:false}); el.addEventListener('click', function(ev){ if(seen) return; handler({currentTarget:el, originalEvent:ev}); }); }

  // ===== State =====
  var board, player, aiPieces, turnCnt, countdown, phase; // 'playerMove'|'chooseAction'|'targetSelect'
  var energy, keysCollected, gatePos, selectedAction;

  // ===== Utils =====
  function cellEl(r,c){ return boardEl.children[r*SIZE+c]; }
  function randInner(){ return Math.floor(Math.random()*(SIZE-2))+1; }
  function randomOf(a){ return a[Math.floor(Math.random()*a.length)]; }
  function create2D(rows, cols, fill){ var m=new Array(rows); for(var r=0;r<rows;r++){ var row=new Array(cols); for(var c=0;c<cols;c++) row[c]=fill; m[r]=row; } return m; }

  function isWalkableFor(tag,v){ if(tag==='player') return (v==='empty'||v==='key'||v==='gate'||v==='trap'); if(tag==='ai') return (v==='empty'||v==='trap'); return false; }
  function legalMoves(ent, tag){ var out=[]; for(var i=0;i<dirs.length;i++){ var nr=ent.r+dirs[i][0], nc=ent.c+dirs[i][1]; if(inBounds(nr,nc) && isWalkableFor(tag, board[nr][nc])) out.push({r:nr,c:nc}); } return out; }

  function flood(sr,sc){ var seen=create2D(SIZE,SIZE,false), q=[[sr,sc]], n=0; seen[sr][sc]=true; while(q.length){ var cur=q.pop(), r=cur[0], c=cur[1]; n++; for(var i=0;i<dirs.length;i++){ var nr=r+dirs[i][0], nc=c+dirs[i][1]; if(inBounds(nr,nc) && !seen[nr][nc] && isWalkableFor('ai',board[nr][nc])){ seen[nr][nc]=true; q.push([nr,nc]); } } } return n; }

  function isPlayerPassable(r,c){ var v=board[r][c]; return (v==='empty'||v==='key'||v==='gate'||v==='trap'||(player&&r===player.r&&c===player.c)); }
  function buildDistMapFrom(sr,sc){ var dist=create2D(SIZE,SIZE,-1), q=[[sr,sc]]; dist[sr][sc]=0; while(q.length){ var cur=q.shift(), r=cur[0], c=cur[1]; for(var i=0;i<dirs.length;i++){ var nr=r+dirs[i][0], nc=c+dirs[i][1]; if(!inBounds(nr,nc) || dist[nr][nc]!==-1) continue; if(isPlayerPassable(nr,nc)){ dist[nr][nc]=dist[r][c]+1; q.push([nr,nc]); } } } return dist; }

  // ===== Build =====
  function ensureBoard(){ if(!boardEl){ var wrap=document.querySelector('.wrap')||document.body; var el=document.createElement('div'); el.id='board'; wrap.appendChild(el); boardEl=el; } return boardEl; }

  function buildBoard(){ ensureBoard(); board=create2D(SIZE,SIZE,'empty'); boardEl.innerHTML=''; boardEl.style.gridTemplateColumns='repeat('+SIZE+',1fr)'; boardEl.style.gridTemplateRows='repeat('+SIZE+',1fr)'; for(var r=0;r<SIZE;r++) for(var c=0;c<SIZE;c++){ var d=document.createElement('div'); d.className='cell'; d.dataset.row=String(r); d.dataset.col=String(c); bindPress(d,onCell); boardEl.appendChild(d); } }

  function placePieces(){
    var tries=0; var placed=false;
    while(!placed && tries<500){ tries++;
      var pr=randInner(), pc=randInner(); var a1r=randInner(), a1c=randInner(); var a2r=randInner(), a2c=randInner();
      if((pr===a1r && pc===a1c) || (pr===a2r && pc===a2c) || (a1r===a2r && a1c===a2c)) continue;
      player={r:pr,c:pc}; aiPieces=[{r:a1r,c:a1c,alive:true},{r:a2r,c:a2c,alive:true}];
      board[pr][pc]='player'; board[a1r][a1c]='ai'; board[a2r][a2c]='ai'; placed=true;
    }
    if(!placed) throw new Error('말 배치 실패');
  }

  function placeKeys(){
    keysCollected=0; gatePos=null;
    var dist=buildDistMapFrom(player.r,player.c);
    var cand=[], r,c;
    for(r=1;r<SIZE-1;r++) for(c=1;c<SIZE-1;c++){
      if(board[r][c]!=='empty') continue; var d=dist[r][c]; if(d>=5) cand.push({r:r,c:c});
    }
    // 부족하면 완화(>=3) → 그래도 부족하면 내부 empty 전체에서 보충
    if(cand.length<3){ for(r=1;r<SIZE-1;r++) for(c=1;c<SIZE-1;c++){ if(board[r][c]!=='empty') continue; var d2=dist[r][c]; if(d2>=3) cand.push({r:r,c:c}); } }
    if(cand.length<3){ for(r=1;r<SIZE-1;r++) for(c=1;c<SIZE-1;c++) if(board[r][c]==='empty') cand.push({r:r,c:c}); }
    var need=TOTAL_KEYS, placed=0;
    while(placed<need && cand.length){ var idx=Math.floor(Math.random()*cand.length); var p=cand.splice(idx,1)[0]; if(board[p.r][p.c]==='empty'){ board[p.r][p.c]='key'; placed++; } }
    if(placed<need) throw new Error('열쇠 배치 실패('+placed+'/'+need+')');
  }

  function chooseGateCellMaxDistanceFrom(sr,sc){
    var dist=buildDistMapFrom(sr,sc), best=-1, bestArr=[], r,c;
    for(r=1;r<SIZE-1;r++) for(c=1;c<SIZE-1;c++){
      var v=board[r][c]; if(v==='sealed'||v==='rune'||v==='tomb') continue; // 규칙: 테두리/봉인/무덤 제외
      if(dist[r][c]<0) continue; // 도달 불가 제외
      if(dist[r][c]>best){ best=dist[r][c]; bestArr=[{r:r,c:c}]; }
      else if(dist[r][c]===best){ bestArr.push({r:r,c:c}); }
    }
    if(bestArr.length) return randomOf(bestArr);
    return null;
  }

  function spawnGateFromPlayerPos(){
    var g=chooseGateCellMaxDistanceFrom(player.r,player.c);
    if(!g) return false; gatePos={r:g.r,c:g.c}; board[g.r][g.c]='gate'; return true;
  }

  function innerEmptyCells(exclude){ var a=[], r,c; for(r=1;r<SIZE-1;r++) for(c=1;c<SIZE-1;c++){ if(exclude && r===exclude.r && c===exclude.c) continue; if(board[r][c]==='empty') a.push({r:r,c:c}); } return a; }
  function spawnExtraAIs(n, exclude){ var pool=innerEmptyCells(exclude); for(var i=0;i<n && pool.length;i++){ var idx=Math.floor(Math.random()*pool.length), p=pool.splice(idx,1)[0]; aiPieces.push({r:p.r,c:p.c,alive:true}); board[p.r][p.c]='ai'; } }

  // ===== Render =====
  function draw(){ for(var r=0;r<SIZE;r++) for(var c=0;c<SIZE;c++){ var el=cellEl(r,c); el.className='cell'; var v=board[r][c]; if(v==='player') el.classList.add('player'); else if(v==='ai') el.classList.add('ai'); else if(v==='sealed') el.classList.add('sealed'); else if(v==='rune') el.classList.add('rune'); else if(v==='tomb') el.classList.add('tomb'); else if(v==='key') el.classList.add('key'); else if(v==='gate') el.classList.add('gate'); else if(v==='trap') el.classList.add('trap'); } }
  function move(ent,r,c,tag){ board[ent.r][ent.c]='empty'; ent.r=r; ent.c=c; board[r][c]=tag; }
  function seal(r,c){ board[r][c]='sealed'; }
  function trap(r,c){ board[r][c]='trap'; }
  function reinforce(r,c){ board[r][c]='rune'; }
  function clearHL(){ var list=boardEl.querySelectorAll('.highlight'); for(var i=0;i<list.length;i++) list[i].classList.remove('highlight'); }
  function hlTargets(pred){ clearHL(); for(var r=0;r<SIZE;r++) for(var c=0;c<SIZE;c++) if(pred(r,c)) cellEl(r,c).classList.add('highlight'); }
  function updateHUD(){ turnEl.textContent=String(turnCnt); leftEl.textContent=String(countdown); energyEl.textContent=String(energy); keysEl.textContent=String(keysCollected); }

  // ===== AI (teamplay) =====
  function playerReachableSize(){ var seen=create2D(SIZE,SIZE,false), q=[[player.r,player.c]], n=0; seen[player.r][player.c]=true; while(q.length){ var cur=q.pop(), r=cur[0], c=cur[1]; n++; for(var i=0;i<dirs.length;i++){ var nr=r+dirs[i][0], nc=c+dirs[i][1]; if(!inBounds(nr,nc)||seen[nr][nc]) continue; var v=board[nr][nc]; if(v!=='ai'&&v!=='sealed'&&v!=='rune'&&v!=='tomb'){ if(v==='empty'||v==='key'||v==='gate'||v==='trap'){ seen[nr][nc]=true; q.push([nr,nc]); } } } } return n; }
  function nearestAIDist(r,c,selfIndex){ var best=9999; for(var i=0;i<aiPieces.length;i++){ if(i===selfIndex) continue; var q=aiPieces[i]; if(!q.alive) continue; var d=Math.abs(r-q.r)+Math.abs(c-q.c); if(d<best) best=d; } return (best===9999)?6:best; }
  function evalAIMove(aiIndex,tr,tc){ var p=aiPieces[aiIndex], sr=p.r, sc=p.c, srcV=board[sr][sc], dstV=board[tr][tc]; board[sr][sc]='empty'; board[tr][tc]='ai'; var aiSpace=flood(tr,tc), playerSpace=playerReachableSize(); var dist=nearestAIDist(tr,tc,aiIndex); var coverage=4-Math.abs(dist-3); var gateScore=0; if(gatePos){ var gd=Math.abs(tr-gatePos.r)+Math.abs(tc-gatePos.c); gateScore=8-Math.min(8,gd); } var Wp=0.9, Wc=0.6, Wg=0.5; var s=(aiSpace)-Wp*(playerSpace)+Wc*(coverage)+Wg*(gateScore)+(Math.random()*0.1); board[tr][tc]=dstV; board[sr][sc]=srcV; return s; }

  function aiTurn(){
    for(var i=0;i<aiPieces.length;i++){
      var p=aiPieces[i]; if(!p.alive) continue; var moves=legalMoves(p,'ai'); if(!moves.length){ board[p.r][p.c]='tomb'; p.alive=false; continue; }
      var best=moves[0], bestS=-1e9; for(var j=0;j<moves.length;j++){ var m=moves[j], s=evalAIMove(i,m.r,m.c); if(s>bestS){ bestS=s; best=m; } }
      if(board[best.r][best.c]==='trap'){ board[p.r][p.c]='empty'; p.r=best.r; p.c=best.c; board[p.r][p.c]='tomb'; p.alive=false; } else { move(p,best.r,best.c,'ai'); }
    }
    draw(); if(checkWin()) return; phase='playerMove'; hlTargets(function(r,c){ var lm=legalMoves(player,'player'); for(var t=0;t<lm.length;t++){ if(lm[t].r===r&&lm[t].c===c) return true; } return false; }); logMsg('플레이어 차례: 이동할 칸을 선택해.');
  }

  // ===== Flow =====
  function declare(w){ clearHL(); logMsg(w+' 승리!'); restartBtn.style.display='inline-block'; actionsEl.style.display='none'; }
  function checkWin(){ if(!legalMoves(player,'player').length){ declare('AI'); return true; } if(gatePos && player.r===gatePos.r && player.c===gatePos.c && keysCollected===TOTAL_KEYS){ declare('플레이어'); return true; } return false; }
  function unseal(k){ var s=[], r,c; for(r=0;r<SIZE;r++) for(c=0;c<SIZE;c++) if(board[r][c]==='sealed') s.push({r:r,c:c}); for(var i=0;i<k && s.length;i++){ var idx=Math.floor(Math.random()*s.length), rc=s.splice(idx,1)[0]; board[rc.r][rc.c]='empty'; } draw(); }
  function advance(){ turnCnt++; countdown--; energy=Math.min(MAX_ENERGY,energy+1); updateHUD(); if(countdown===0){ unseal(UNSEAL_COUNT); countdown=UNSEAL_INTERVAL; logMsg('5턴 경과! 봉인 2칸 해제.'); var alive=0; for(var i=0;i<aiPieces.length;i++) if(aiPieces[i].alive) alive++; if(alive<3){ var pool=innerEmptyCells(); if(pool.length){ var s=randomOf(pool); aiPieces.push({r:s.r,c:s.c,alive:true}); board[s.r][s.c]='ai'; draw(); logMsg('5턴 경과! 봉인 2칸 해제. 신규 AI가 나타났어.'); } } } }

  function afterPlayerMoved(){ draw(); phase='chooseAction'; selectedAction=null; actionsEl.style.display='flex'; updateActionsEnabled(); logMsg('행동을 골라: 봉인 / 함정 / 강봉인'+(keysCollected===TOTAL_KEYS?' / 스킵 / 해체':'')); }
  function endPlayer(){ clearHL(); actionsEl.style.display='none'; advance(); if(checkWin()) return; aiTurn(); }

  function onCell(e){ var r=+e.currentTarget.dataset.row, c=+e.currentTarget.dataset.col; if(phase==='playerMove'){ if(!e.currentTarget.classList.contains('highlight')) return; var destVal=board[r][c]; move(player,r,c,'player'); if(destVal==='key'){ keysCollected++; updateHUD(); if(keysCollected===TOTAL_KEYS && !gatePos){ var ok=spawnGateFromPlayerPos(); if(ok){ spawnExtraAIs(3, gatePos); logMsg('모든 키를 모았어! 게이트가 열렸고, AI가 3기 더 나타났어.'); }else{ logMsg('모든 키를 모았지만 게이트 생성에 실패했어…'); } } } draw(); afterPlayerMoved(); } else if(phase==='targetSelect'){ if(!e.currentTarget.classList.contains('highlight')) return; if(selectedAction==='seal'){ if(board[r][c]!=='empty') return; seal(r,c); draw(); endPlayer(); } else if(selectedAction==='trap'){ if(energy<2 || board[r][c]!=='empty') return; trap(r,c); energy-=2; updateHUD(); draw(); endPlayer(); } else if(selectedAction==='rune'){ if(energy<1 || board[r][c]!=='sealed') return; reinforce(r,c); energy-=1; updateHUD(); draw(); endPlayer(); } else if(selectedAction==='dispel'){ if(keysCollected!==TOTAL_KEYS) return; var v=board[r][c]; if(energy<3 || (v!=='sealed' && v!=='rune')) return; board[r][c]='empty'; energy-=3; updateHUD(); draw(); endPlayer(); } } }

  function updateActionsEnabled(){ var btns=actionsEl.querySelectorAll('button'); for(var i=0;i<btns.length;i++) btns[i].disabled=false; var trapBtn=actionsEl.querySelector('[data-act="trap"]'); var runeBtn=actionsEl.querySelector('[data-act="rune"]'); var skipBtn=actionsEl.querySelector('[data-act="skip"]'); var dispelBtn=actionsEl.querySelector('[data-act="dispel"]'); if(trapBtn){ if(energy<2) trapBtn.setAttribute('disabled',''); else trapBtn.removeAttribute('disabled'); } if(runeBtn){ if(energy<1) runeBtn.setAttribute('disabled',''); else runeBtn.removeAttribute('disabled'); } var post=(keysCollected===TOTAL_KEYS); if(skipBtn){ skipBtn.style.display=post?'inline-block':'none'; if(!post) skipBtn.setAttribute('disabled',''); else skipBtn.removeAttribute('disabled'); } if(dispelBtn){ dispelBtn.style.display=post?'inline-block':'none'; if(!post || energy<3) dispelBtn.setAttribute('disabled',''); else dispelBtn.removeAttribute('disabled'); } }

  // ===== Controls =====
  var btnSeal=document.querySelector('#actions [data-act="seal"]');
  var btnTrap=document.querySelector('#actions [data-act="trap"]');
  var btnRune=document.querySelector('#actions [data-act="rune"]');
  var btnSkip=document.querySelector('#actions [data-act="skip"]');
  var btnDispel=document.querySelector('#actions [data-act="dispel"]');

  function onSeal(){ selectedAction='seal'; hlTargets(function(r,c){ return board[r][c]==='empty'; }); phase='targetSelect'; logMsg('봉인할 칸을 골라.'); }
  function onTrap(){ selectedAction='trap'; hlTargets(function(r,c){ return board[r][c]==='empty'; }); phase='targetSelect'; logMsg('함정 설치할 칸을 골라.'); }
  function onRune(){ selectedAction='rune'; hlTargets(function(r,c){ return board[r][c]==='sealed'; }); phase='targetSelect'; logMsg('강봉인할 칸을 골라.'); }
  function onSkip(){ if(keysCollected===TOTAL_KEYS){ endPlayer(); } }
  function onDispel(){ if(keysCollected!==TOTAL_KEYS) return; if(energy<3){ logMsg('에너지가 부족해…(필요:3)'); return; } selectedAction='dispel'; hlTargets(function(r,c){ return board[r][c]==='sealed' || board[r][c]==='rune'; }); phase='targetSelect'; logMsg('해체할 칸을 골라.'); }

  bindPress(btnSeal, onSeal); bindPress(btnTrap, onTrap); bindPress(btnRune, onRune); bindPress(btnSkip, onSkip); bindPress(btnDispel, onDispel);

  // ===== Start =====
  function start(){
    logMsg('초기화 중…');
    buildBoard(); logMsg('보드 생성 완료…');
    placePieces(); logMsg('말 배치 완료…');
    placeKeys(); logMsg('키 배치 완료. 시작할 수 있어.');
    turnCnt=0; countdown=UNSEAL_INTERVAL; energy=1; gatePos=null; phase='playerMove';
    updateHUD(); draw(); actionsEl.style.display='none'; restartBtn.style.display='none'; startBtn.style.display='none';
    hlTargets(function(r,c){ var lm=legalMoves(player,'player'); for(var t=0;t<lm.length;t++){ if(lm[t].r===r&&lm[t].c===c) return true; } return false; });
    logMsg('플레이어 차례: 이동할 칸을 선택해.');
  }
  function safeStart(){ try{ start(); }catch(err){ console.error(err); logMsg('시작 오류: '+(err && err.message ? err.message : String(err))); } }
  bindPress(startBtn, function(){ logMsg('시작 버튼 눌렀어…'); safeStart(); });
  bindPress(restartBtn, function(){ safeStart(); });

  document.addEventListener('DOMContentLoaded', function(){ logMsg('준비됐어. 게임시작을 눌러줘.'); });
})();
</script>

</body>
</html>
